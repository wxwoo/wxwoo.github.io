{"meta":{"title":"wxwoo's blog","subtitle":null,"description":null,"author":"wxwoo","url":"http://wxwoo.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-06-21T14:03:05.629Z","updated":"2019-06-21T14:03:05.629Z","comments":true,"path":"404.html","permalink":"http://wxwoo.github.io/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在 请检查url或该文章已被删除"},{"title":"所有分类","date":"2019-03-19T10:43:52.542Z","updated":"2019-03-19T10:43:52.542Z","comments":true,"path":"categories/index.html","permalink":"http://wxwoo.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-24T09:29:23.331Z","updated":"2019-07-24T09:29:23.331Z","comments":true,"path":"friends/index.html","permalink":"http://wxwoo.github.io/friends/index.html","excerpt":"","text":"欢迎各位交换友链！必须有名称、blog链接和头像链接！尽量有标签！标签可以有多个！（默认为你的blog的标题）有修改的请在下方留言！格式： 名称：头像链接：blog主页：标签： 标签1 标签2……"},{"title":"所有标签","date":"2019-03-19T10:43:50.112Z","updated":"2019-03-19T10:43:50.112Z","comments":true,"path":"tags/index.html","permalink":"http://wxwoo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"P2136 拉近距离 题解","slug":"solution-p2136","date":"2019-07-26T16:00:00.000Z","updated":"2019-07-30T00:50:10.300Z","comments":true,"path":"2019/07/27/solution-p2136/","link":"","permalink":"http://wxwoo.github.io/2019/07/27/solution-p2136/","excerpt":"","text":"原题目链接 此题显然为有向图判负权环板子题 没做过请先右转模板【负环】 此题关键点： 小明和小红的生活中，有N个关键的节点。有M个事件，记为一个三元组（Si，Ti，Wi），表示从节点Si有一个事件可以转移到Ti，事件的效果就是使他们之间的距离减少Wi。 所以建边时，要把权值变为相反数 然后以1为源点进行SPFA求负环，就AC了 ……吗？ 交上去一看，WA90！ 此题最大关键点： 题目中没有说明是“小明向小红‘拉近距离’”还是“小红向小明‘拉近距离’”！ 题目背景是小明说的，不代表小红观点，所以不算 所以我们还需要以n为源点进行SPFA求负环 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;template&lt;typename T&gt;inline void read(T &amp;x)&#123; int ch=getchar(); T f=1; x=0; while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')) &#123; if(ch=='-') f=-1; ch=getchar(); &#125; while('0'&lt;=ch&amp;&amp;ch&lt;='9') &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125; x*=f;&#125;const int N=1e4+10;int n,m;int head[N],to[(N*10)&lt;&lt;1],nxt[(N*10)&lt;&lt;1],w[(N*10)&lt;&lt;1],e;int ans[N],cnt[N];bool vis[N];queue&lt;int&gt;q;inline void add(const int &amp;u,const int &amp;v,const int &amp;c)&#123; to[++e]=v; w[e]=c; nxt[e]=head[u]; head[u]=e;&#125;inline bool spfa(const int &amp;s)&#123; while(!q.empty()) q.pop(); memset(ans,0x3f,sizeof(ans)); memset(vis,0,sizeof(vis)); memset(cnt,0,sizeof(cnt)); ans[s]=0; vis[s]=1; q.push(s); while(!q.empty()) &#123; int x=q.front(); q.pop(); vis[x]=0; for(int i=head[x];i;i=nxt[i]) &#123; int y=to[i]; if(ans[y]&gt;ans[x]+w[i]) &#123; ans[y]=ans[x]+w[i]; cnt[y]=cnt[x]+1; if(cnt[y]&gt;n) return 1; if(!vis[y]) &#123; vis[y]=1; q.push(y); &#125; &#125; &#125; &#125; return 0;&#125;int main()&#123; read(n); read(m); int u,v,w; for(int i=1;i&lt;=m;++i) &#123; read(u); read(v); read(w); add(u,v,-w); &#125; if(spfa(1)) &#123; printf(\"Forever love\"); return 0; &#125; int res=ans[n]; if(spfa(n)) printf(\"Forever love\"); else printf(\"%d\",min(res,ans[1])); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"http://wxwoo.github.io/categories/题解/洛谷/"}],"tags":[{"name":"负环","slug":"负环","permalink":"http://wxwoo.github.io/tags/负环/"},{"name":"SPFA","slug":"SPFA","permalink":"http://wxwoo.github.io/tags/SPFA/"}]},{"title":"P4177 [CEOI2008]order 题解","slug":"solution-p4177","date":"2019-07-09T16:00:00.000Z","updated":"2019-07-24T09:30:30.083Z","comments":true,"path":"2019/07/10/solution-p4177/","link":"","permalink":"http://wxwoo.github.io/2019/07/10/solution-p4177/","excerpt":"原题目链接 先无视租机器，明显的最大权闭合子图 最大权闭合子图： 给定一个有向图，点有点权，选择一个子图，满足子图上如果选择了一个点就必须选择它后继的所有点。最大化点权和。 我们将机器和任务都看成一个点 如果这题没有租机器，这题的建边方式就应该是这样： 源点向订单连流量为利润的边 机器向汇点连流量为购买价格的边 每个订单向需要的机器连流量为inf的边 可以发现，源点连的边都是订单的利润，汇点连的边都是机器的成本，只有机器和订单之间的边是$inf$ 对于每个订单需要的相同机器，租用的价格也不一样 所以我们考虑把$inf$换成租机器的费用","text":"原题目链接 先无视租机器，明显的最大权闭合子图 最大权闭合子图： 给定一个有向图，点有点权，选择一个子图，满足子图上如果选择了一个点就必须选择它后继的所有点。最大化点权和。 我们将机器和任务都看成一个点 如果这题没有租机器，这题的建边方式就应该是这样： 源点向订单连流量为利润的边 机器向汇点连流量为购买价格的边 每个订单向需要的机器连流量为inf的边 可以发现，源点连的边都是订单的利润，汇点连的边都是机器的成本，只有机器和订单之间的边是$inf$ 对于每个订单需要的相同机器，租用的价格也不一样 所以我们考虑把$inf$换成租机器的费用 从正确性的角度考虑，跑最大流（最小割）是计算最优方案下的成本，若总租借费用低于购买机器费用，表示购买费用的那条边就不会满流，防止购买机器反而增加成本；反之表示购买费用的那条边就会满流，限制住成本因多次租用同一机器而增加 最终建边方式如下： 源点向订单连流量为利润的边 机器向汇点连流量为购买价格的边 每个订单向需要的机器连流量为租用费用的边 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;template&lt;typename T&gt;inline void read(T &amp;x)&#123; int ch=getchar(); T f=1; x=0; while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')) &#123; if(ch=='-') f=-1; ch=getchar(); &#125; while('0'&lt;=ch&amp;&amp;ch&lt;='9') &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125; x*=f;&#125;const int inf=1e9,N=3e5+1;struct edge&#123; int from,to,nxt,cap,flow;&#125;e[N*20];int cnt,n,m,sour,sink,head[N],ans,q[N],l[N],p[N];inline void add(const int &amp;u,const int &amp;v,const int &amp;f)&#123; e[++cnt]=(edge)&#123;u,v,head[u],f,0&#125;; head[u]=cnt; e[++cnt]=(edge)&#123;v,u,head[v],0,0&#125;; head[v]=cnt;&#125;inline bool find()&#123; memset(l,0,sizeof(l)); int h=1,t=1; q[1]=sour; l[sour]=1; while(h&lt;=t) &#123; int x=q[h++]; for(int i=head[x];i;i=e[i].nxt) &#123; if(!l[e[i].to]&amp;&amp;e[i].cap&gt;e[i].flow) &#123; q[++t]=e[i].to; l[e[i].to]=l[x]+1; if(e[i].to==sink) return 1; &#125; &#125; &#125; return 0;&#125;int dfs(const int &amp;x,const int &amp;now)&#123; if(x==sink||!now) return now; int t=now,detla; for(int i=head[x];i;i=e[i].nxt) &#123; if(e[i].cap&gt;e[i].flow&amp;&amp;l[e[i].to]==l[x]+1) &#123; detla=dfs(e[i].to,min(t,e[i].cap-e[i].flow)); if(!detla) l[e[i].to]=0; e[i].flow+=detla; e[((i-1)^1)+1].flow-=detla; t-=detla; if(t==0) break; &#125; &#125; return now-t;&#125;inline void dinic()&#123; while(find()) ans+=dfs(sour,inf);&#125;int main()&#123; read(n); read(m); sour=0; sink=n+m+1; int u,v,t,r,tot=0; for(int i=1;i&lt;=n;++i) &#123; read(v); read(t); add(sour,i,v); for(int j=1;j&lt;=t;++j) &#123; read(u); read(r); add(i,u+n,r); &#125; tot+=v; &#125; for(int i=1;i&lt;=m;++i) &#123; read(v); add(i+n,sink,v); &#125; dinic(); printf(\"%d\",tot-ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"http://wxwoo.github.io/categories/题解/洛谷/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://wxwoo.github.io/tags/网络流/"}]},{"title":"SP1476 PROFIT - Maximum Profit 题解","slug":"solution-sp1476","date":"2019-06-14T16:00:00.000Z","updated":"2019-06-21T12:51:31.467Z","comments":true,"path":"2019/06/15/solution-sp1476/","link":"","permalink":"http://wxwoo.github.io/2019/06/15/solution-sp1476/","excerpt":"原题目链接 明显的最大权闭合子图 最大权闭合子图： 给定一个有向图，点有点权，选择一个子图，满足子图上如果选择了一个点就必须选择它后继的所有点。最大化点权和。 经典的网络流问题，具体使用最小割求解 我们将顾客和通讯站都看成一个点，然后如下建边： 源点向顾客连流量为利润的边 通讯站向汇点连流量为成本的边 每个顾客向需要的通讯站连流量为inf的边","text":"原题目链接 明显的最大权闭合子图 最大权闭合子图： 给定一个有向图，点有点权，选择一个子图，满足子图上如果选择了一个点就必须选择它后继的所有点。最大化点权和。 经典的网络流问题，具体使用最小割求解 我们将顾客和通讯站都看成一个点，然后如下建边： 源点向顾客连流量为利润的边 通讯站向汇点连流量为成本的边 每个顾客向需要的通讯站连流量为inf的边 接下来我们思考这样建边的正确性 在最小割模型中，连一条流量为$inf$的边意为连一条不可割边 那么这个图中的可割边就只有顾客和通讯站了 跑最大流（最小割）即为计算最优方案下的成本 最终答案（最大净利润）为全部顾客能赚到的钱减去最小割 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int inf=1e9;const int N=3e6;struct edge&#123; int from,to,next,cap,flow;&#125;e[N];int cnt,n,m,r,sour,sink,head[N],l[N],ans,q[N],p[N],tot;inline int min(int i,int j)&#123; return i&lt;j?i:j;&#125;int dfs(int x,int now)&#123; if(x==sink||!now) return now; int t=now,detla; for(int i=head[x];i;i=e[i].next) &#123; if(e[i].cap&gt;e[i].flow&amp;&amp;l[e[i].to]==l[x]+1) &#123; detla=dfs(e[i].to,min(t,e[i].cap-e[i].flow)); if(!detla) l[e[i].to]=0; e[i].flow+=detla; e[((i-1)^1)+1].flow-=detla; t-=detla; if(t==0) break; &#125; &#125; return now-t;&#125;inline void add(int u,int v,int l)&#123; e[++cnt]=(edge)&#123;u,v,head[u],l,0&#125;; head[u]=cnt; e[++cnt]=(edge)&#123;v,u,head[v],0,0&#125;; head[v]=cnt;&#125;inline bool find()&#123; memset(l,0,sizeof(l)); int h=1,t=1; q[1]=sour; l[sour]=1; while(h&lt;=t) &#123; int x=q[h++]; for(int i=head[x];i;i=e[i].next) if(!l[e[i].to]&amp;&amp;e[i].cap&gt;e[i].flow) &#123; q[++t]=e[i].to; l[e[i].to]=l[x]+1; if(e[i].to==sink) return true; &#125; &#125; return false;&#125;inline void dinic()&#123; while(find()) ans+=dfs(sour,inf);&#125;inline void read(int &amp;x)&#123; char ch; int f=1; x=0; do &#123; if(ch=='-') f=-1; ch=getchar(); &#125;while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')); do &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125;while('0'&lt;=ch&amp;&amp;ch&lt;='9'); x*=f;&#125;int main()&#123; int _; read(_); ++_; while(--_) &#123; cnt=0; ans=0; tot=0; memset(e,0,sizeof(e)); memset(head,0,sizeof(head)); read(n); read(m); sour=0; sink=n+m+1; for(int i=1;i&lt;=n;i++) &#123; int r; read(r); add(i+m,sink,r); &#125; for(int i=1;i&lt;=m;i++) &#123; int a,b,c; read(a); read(b); read(c); add(i,a+m,inf); add(i,b+m,inf); add(sour,i,c); tot+=c; &#125; dinic(); printf(\"%d\\n\",tot-ans); &#125; return 0;&#125; 双倍经验：P4174 [NOI2006]最大获利，快去骗经验啊qwq","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"SPOJ","slug":"题解/SPOJ","permalink":"http://wxwoo.github.io/categories/题解/SPOJ/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://wxwoo.github.io/tags/网络流/"}]},{"title":"SP2916 GSS5 - Can you answer these queries V 题解","slug":"solution-sp2916","date":"2019-06-13T16:00:00.000Z","updated":"2019-07-05T14:34:32.885Z","comments":true,"path":"2019/06/14/solution-sp2916/","link":"","permalink":"http://wxwoo.github.io/2019/06/14/solution-sp2916/","excerpt":"原题目链接 前置知识：不带修区间最大子段和 没做过请先右转GSS1 这题比GSS1多了一个对左右端点的区间限制，GSS1的做法不再适用 这时我们就要分两种情况讨论","text":"原题目链接 前置知识：不带修区间最大子段和 没做过请先右转GSS1 这题比GSS1多了一个对左右端点的区间限制，GSS1的做法不再适用 这时我们就要分两种情况讨论 情况1：左右端点的区间不相交，即$[x_1,y_1]\\cap[x_2,y_2]=\\varnothing$ 此时$[y_1+1,x_2-1]$为必选区间，我们只能最大化$[x_1,y_1]$的后缀和和$[x_2,y_2]$的前缀和，加上$[y_1+1,x_2-1]$的和即为答案 情况2：左右端点的区间相交，即$[x_1,y_1]\\cap[x_2,y_2]\\ne\\varnothing$ 设最终答案区间左右端点分别为$x_{ans},y_{ans}$ 此时答案分4种情况： $\\{y_1,x_2\\}\\subsetneqq[x_{ans},y_{ans}]$ $\\{y_1\\}\\subsetneqq[x_{ans},y_{ans}]$ $\\{x_2\\}\\subsetneqq[x_{ans},y_{ans}]$ $\\{y_1,x_2\\}\\nsubseteqq[x_{ans},y_{ans}]$ 情况1即为刚才讨论的左右端点区间不相交的情况 情况2可以最大化$[x_1,y_1]$的后缀和和$[y_1,y_2]$的前缀和求出 情况3可以最大化$[x_1,x_2]$的后缀和和$[x_2,y_2]$的前缀和求出 情况4即为求$[x_2,y_1]$的最大子段和 答案即为这4种情况中的最大值 不难发现，若情况1为最优，则情况1，2，3相等 所以情况1可以通过情况2或3来求出 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;template&lt;typename T&gt; inline void read(T &amp;x)&#123; char ch=getchar(); T f=1; x=0; while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')) &#123; if(ch=='-') f=-1; ch=getchar(); &#125; while('0'&lt;=ch&amp;&amp;ch&lt;='9') &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125; x*=f;&#125;const int N=50010;struct sgttree&#123; int left,right,sum,ans;&#125;t[N&lt;&lt;2];int n,m;int a[N];#define ls(p) p&lt;&lt;1#define rs(p) p&lt;&lt;1|1inline sgttree pushup(sgttree ls,sgttree rs)&#123; sgttree tmp; tmp.sum=ls.sum+rs.sum; tmp.left=max(ls.left,ls.sum+rs.left); tmp.right=max(rs.right,rs.sum+ls.right); tmp.ans=max(max(ls.ans,rs.ans),ls.right+rs.left); return tmp;&#125;void build(int p,int l,int r)&#123; if(l==r) &#123; t[p].ans=t[p].sum=t[p].left=t[p].right=a[l]; return; &#125; int mid=l+r&gt;&gt;1; build(ls(p),l,mid); build(rs(p),mid+1,r); t[p]=pushup(t[ls(p)],t[rs(p)]);&#125;sgttree query(int ql,int qr,int l,int r,int p)&#123; if(ql&gt;qr) return (sgttree)&#123;0,0,0,0&#125;; if(ql&lt;=l&amp;&amp;r&lt;=qr) &#123; return t[p]; &#125; int mid=l+r&gt;&gt;1; if(qr&lt;=mid) return query(ql,qr,l,mid,ls(p)); if(mid&lt;ql) return query(ql,qr,mid+1,r,rs(p)); sgttree ls,rs; if(ql&lt;=mid) ls=query(ql,qr,l,mid,ls(p)); if(mid&lt;qr) rs=query(ql,qr,mid+1,r,rs(p)); return pushup(ls,rs);&#125;int main()&#123; int _; read(_); ++_; while(--_) &#123; memset(t,0,sizeof(t)); read(n); for(int i=1;i&lt;=n;++i) read(a[i]); build(1,1,n); read(m); ++m; int ll,lr,rl,rr; while(--m) &#123; read(ll); read(lr); read(rl); read(rr); if(lr&lt;rl) printf(\"%d\\n\",query(lr+1,rl-1,1,n,1).sum+query(ll,lr,1,n,1).right+query(rl,rr,1,n,1).left); else &#123; int res=query(rl,lr,1,n,1).ans; if(ll&lt;rl) res=max(res,query(ll,rl,1,n,1).right+query(rl,rr,1,n,1).left-a[rl]); if(rr&gt;lr) res=max(res,query(ll,lr,1,n,1).right+query(lr,rr,1,n,1).left-a[lr]); printf(\"%d\\n\",res); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"SPOJ","slug":"题解/SPOJ","permalink":"http://wxwoo.github.io/categories/题解/SPOJ/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://wxwoo.github.io/tags/线段树/"}]},{"title":"SP3978 DISQUERY - Distance Query 题解","slug":"solution-sp3978","date":"2019-05-26T16:00:00.000Z","updated":"2019-05-30T10:37:04.726Z","comments":true,"path":"2019/05/27/solution-sp3978/","link":"","permalink":"http://wxwoo.github.io/2019/05/27/solution-sp3978/","excerpt":"原题目链接 树上链最值查询 做法很多，LCT，树上倍增，树剖都可以 但由于LCT常数过大，树上倍增比树剖常数大，这里使用树链剖分 边权转点权是树剖常用套路，将边权转成深度较大的点的点权，查询时注意避开两点的LCA的权值 由于不带修改，树剖后用ST表维护，时间复杂度$\\mathcal{O}(n\\log n)$，比用线段树维护$\\mathcal{O}(n\\log ^2n)$还少一个log","text":"原题目链接 树上链最值查询 做法很多，LCT，树上倍增，树剖都可以 但由于LCT常数过大，树上倍增比树剖常数大，这里使用树链剖分 边权转点权是树剖常用套路，将边权转成深度较大的点的点权，查询时注意避开两点的LCA的权值 由于不带修改，树剖后用ST表维护，时间复杂度$\\mathcal{O}(n\\log n)$，比用线段树维护$\\mathcal{O}(n\\log ^2n)$还少一个log 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;template&lt;typename T&gt;inline void read(T &amp;x)&#123; char ch=getchar(); T f=1; x=0; while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')) &#123; if(ch=='-') f=-1; ch=getchar(); &#125; while('0'&lt;=ch&amp;&amp;ch&lt;='9') &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125; x*=f;&#125;const int N=100010,logN=20;int n,m;int head[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],w[N&lt;&lt;1],e;int fa[N],son[N],dep[N],wt[N],sz[N],id[N],seq[N],top[N],cnt;int st[N][logN][2],_log[N];inline void add(int u,int v,int f)&#123; to[++e]=v; w[e]=f; nxt[e]=head[u]; head[u]=e;&#125;inline void build()&#123; _log[0]=-1; for(int i=1;i&lt;=n;++i) &#123; st[i][0][0]=st[i][0][1]=wt[seq[i]]; _log[i]=_log[i&gt;&gt;1]+1; &#125; for(int j=1;j&lt;=logN;++j) &#123; for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i) &#123; st[i][j][0]=max(st[i][j-1][0],st[i+(1&lt;&lt;j-1)][j-1][0]); st[i][j][1]=min(st[i][j-1][1],st[i+(1&lt;&lt;j-1)][j-1][1]); &#125; &#125;&#125;inline int qmax(int x,int y)&#123; int s=_log[y-x+1]; return max(st[x][s][0],st[y-(1&lt;&lt;s)+1][s][0]);&#125;inline int qmin(int x,int y)&#123; int s=_log[y-x+1]; return min(st[x][s][1],st[y-(1&lt;&lt;s)+1][s][1]);&#125;void dfs1(int x,int f,int d)&#123; fa[x]=f; dep[x]=d+1; sz[x]=1; for(int i=head[x];i;i=nxt[i]) &#123; int y=to[i]; if(y==f) continue; wt[y]=w[i]; dfs1(y,x,d+1); sz[x]+=sz[y]; if(sz[y]&gt;sz[son[x]]) son[x]=y; &#125;&#125;void dfs2(int x,int t)&#123; id[x]=++cnt; top[x]=t; seq[cnt]=x; if(!son[x]) return; dfs2(son[x],t); for(int i=head[x];i;i=nxt[i]) &#123; int y=to[i]; if(y==fa[x]||y==son[x]) continue; dfs2(y,y); &#125;&#125;inline int querymin(int x,int y)&#123; int ans=0x3f3f3f3f; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); ans=min(ans,qmin(id[top[x]],id[x])); x=fa[top[x]]; &#125; if(dep[x]&gt;dep[y]) swap(x,y); if(x==y) return ans; return min(ans,qmin(id[x]+1,id[y]));&#125;inline int querymax(int x,int y)&#123; int ans=-0x3f3f3f3f; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); ans=max(ans,qmax(id[top[x]],id[x])); x=fa[top[x]]; &#125; if(dep[x]&gt;dep[y]) swap(x,y); if(x==y) return ans; return max(ans,qmax(id[x]+1,id[y]));&#125;int main()&#123; read(n); int u,v,f; for(int i=1;i&lt;n;++i) &#123; read(u); read(v); read(f); add(u,v,f); add(v,u,f); &#125; dfs1(1,1,1); dfs2(1,1); build(); read(m); ++m; while(--m) &#123; read(u); read(v); printf(\"%d %d\\n\",querymin(u,v),querymax(u,v)); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"SPOJ","slug":"题解/SPOJ","permalink":"http://wxwoo.github.io/categories/题解/SPOJ/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"http://wxwoo.github.io/tags/树链剖分/"},{"name":"ST表","slug":"ST表","permalink":"http://wxwoo.github.io/tags/ST表/"}]},{"title":"hexo中的mathjax数学公式渲染优化","slug":"hexo-mathjax-renderer-optimization","date":"2019-05-14T16:00:00.000Z","updated":"2019-06-21T13:08:49.990Z","comments":true,"path":"2019/05/15/hexo-mathjax-renderer-optimization/","link":"","permalink":"http://wxwoo.github.io/2019/05/15/hexo-mathjax-renderer-optimization/","excerpt":"在使用hexo博客和material-x等博客主题时，难免会遇到mathjax数学公式渲染失败或者与markdown渲染冲突的问题。 xaoxuu给出了解决方案，只需在_config.yml里加入mathjax: true即可解决，可以解决大量的mathjax公式渲染，但仍有部分复杂的公式渲染出现问题。 我在这里给出一种解决方案。 注：部分资料来自互联网","text":"在使用hexo博客和material-x等博客主题时，难免会遇到mathjax数学公式渲染失败或者与markdown渲染冲突的问题。 xaoxuu给出了解决方案，只需在_config.yml里加入mathjax: true即可解决，可以解决大量的mathjax公式渲染，但仍有部分复杂的公式渲染出现问题。 我在这里给出一种解决方案。 注：部分资料来自互联网 mathjax渲染修改1. 修改渲染引擎更改hexo的默认渲染引擎，使其支持mathjax 打开cmd，cd到hexo博客文件夹下，输入 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 2. 更改配置找到/node_modules/hexo-renderer-kramed/lib/renderer.js，将1234function formatText(text) &#123; // Fit kramed's rule: $$ + \\1 + $$ return text.replace(/`\\ $(.*?)\\$ `/g, ' $$$$$ 1 $$$$ ');&#125; 改为123function formatText(text) &#123; return text;&#125; 3. 修改数学包在cmd中输入12npm uninstall hexo-math --savenpm install hexo-renderer-mathjax --save 4. 更新mathjax配置文件找到/node_modules/hexo-renderer-mathjax/mathjax.html，将最下面那一行&lt;script&gt;注释掉，改成1&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"&gt;&lt;/script&gt; 5. 修改转义规则因为markdown和mathjax语法有冲突，我们修改转义规则以避免冲突 找到\\node_modules\\kramed\\lib\\rules\\inline.js，将escape和em这两行注释掉，改成 123escape: /^\\\\([`*\\[\\]()# +\\-.!_&gt;])/,em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 6. 开始使用找到\\_config.yml，加上一行mathjax: true就可以了 mathjax渲染优化其实这应该就结束了 但不知什么原因，部分情况直接渲染出来会有一个灰色的框，十分难看 所以我们还要进行优化 打开/node_modules/hexo-renderer-mathjax/mathjax.html，在MathJax.Hub.Config中加上12extensions: [\"tex2jax.js\"],jax: [\"input/TeX\", \"output/HTML-CSS\"], 将刚刚第4步修改的链接修改为1&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_HTMLCSS\"&gt;&lt;/script&gt; 就可以了 但是仍然有一些不尽人意的地方，比如： 部分公式渲染出错比如这个公式：1$\\dfrac&#123;1&#125;&#123;2&#125;$ 显示Undefined control sequence \\dfrac 不仅是这个，还有很多会出错，比如\\geqslant 这是由于更改链接后，缺少了amsmath包 在MathJax.Hub.Config中加上1234TeX: &#123; equationNumbers: &#123; autoNumber: \"AMS\" &#125;, extensions: [\"AMSmath.js\", \"AMSsymbols.js\"]&#125;, 即可解决 修改字体在MathJax.Hub.Config中加上1234\"HTML-CSS\": &#123; preferredFont: \"TeX\", availableFonts: [\"STIX\",\"TeX\"]&#125; 其实这没什么用 关闭右下角加载信息在MathJax.Hub.Config中加上12showProcessingMessages: false,messageStyle: \"none\", 关闭右键菜单在&quot;HTML-CSS&quot;中加上1showMathMenu: false 代码整合可以根据需要自行修改 123456789101112131415161718192021222324252627&lt;script type=\"text/x-mathjax-config\"&gt; MathJax.Hub.Config(&#123; TeX: &#123; equationNumbers: &#123; autoNumber: \"AMS\" &#125;, extensions: [\"AMSmath.js\", \"AMSsymbols.js\"] &#125;, \"HTML-CSS\": &#123; preferredFont: \"TeX\", availableFonts: [\"STIX\", \"TeX\"], showMathMenu: false &#125;, showProcessingMessages: false, messageStyle: \"none\", extensions: [\"tex2jax.js\"], jax: [\"input/TeX\", \"output/HTML-CSS\"], tex2jax: &#123; inlineMath: [ [\"$\",\"$\"] ], skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'a'] &#125; &#125;); MathJax.Hub.Queue(function() &#123; var all = MathJax.Hub.getAllJax(); for (var i = 0; i &lt; all.length; ++i) all[i].SourceElement().parentNode.className += ' has-jax'; &#125;);&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_HTMLCSS\"&gt;&lt;/script&gt;","categories":[],"tags":[{"name":"mathjax","slug":"mathjax","permalink":"http://wxwoo.github.io/tags/mathjax/"},{"name":"hexo","slug":"hexo","permalink":"http://wxwoo.github.io/tags/hexo/"},{"name":"material-x","slug":"material-x","permalink":"http://wxwoo.github.io/tags/material-x/"}]},{"title":"CF1156A Inscribed Figures 题解","slug":"solution-cf1156a","date":"2019-05-01T16:00:00.000Z","updated":"2019-05-01T17:00:23.625Z","comments":true,"path":"2019/05/02/solution-cf1156a/","link":"","permalink":"http://wxwoo.github.io/2019/05/02/solution-cf1156a/","excerpt":"原题目链接 PS： 这题比赛时当场出锅…… std被hack…… 整场比赛最后unrated…… 对于每两个相邻的图形，交点数是固定的 也就是说我们可以打表 12345 1 2 3 1 / 3 42 3 / inf3 4 inf / 但是！直接打表是错误的！std就是这样被hack的！","text":"原题目链接 PS： 这题比赛时当场出锅…… std被hack…… 整场比赛最后unrated…… 对于每两个相邻的图形，交点数是固定的 也就是说我们可以打表 12345 1 2 3 1 / 3 42 3 / inf3 4 inf / 但是！直接打表是错误的！std就是这样被hack的！考虑这样一组数据： 1233 1 2 按照上面的那张表计算，答案是7 但是实际上，三角形，圆形，正方形共用了一个交点 所以答案是6 所以对于每组这样的情况，要进行特判 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;template&lt;typename T&gt; inline void read(T &amp;x)&#123; char ch=getchar(); T f=1; x=0; while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')) &#123; if(ch=='-') f=-1; ch=getchar(); &#125; while('0'&lt;=ch&amp;&amp;ch&lt;='9') &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125; x*=f;&#125;int n;long long ans;const int inf=0x3f3f3f3f;const int res[4][4]=&#123;0,0,0,0, 0,0,3,4, 0,3,0,inf, 0,4,inf,0,&#125;;//打表int a[110];int main()&#123; read(n); for(int i=1;i&lt;=n;++i) &#123; read(a[i]); &#125; for(int i=2;i&lt;=n;++i) &#123; ans+=res[a[i-1]][a[i]];//计算交点数 &#125; for(int i=3;i&lt;=n;++i) &#123; if(a[i-1]==1&amp;&amp;a[i-2]==3&amp;&amp;a[i]==2)//特判特殊情况 --ans; &#125; if(ans&gt;=inf) &#123; printf(\"Infinite\\n\"); &#125; else &#123; printf(\"Finite\\n\"); cout&lt;&lt;ans; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"codeforces","slug":"题解/codeforces","permalink":"http://wxwoo.github.io/categories/题解/codeforces/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://wxwoo.github.io/tags/模拟/"}]},{"title":"SP1296 SUMFOUR - 4 values whose sum is 0 题解","slug":"solution-sp1296","date":"2019-04-22T16:00:00.000Z","updated":"2019-04-26T08:08:29.463Z","comments":true,"path":"2019/04/23/solution-sp1296/","link":"","permalink":"http://wxwoo.github.io/2019/04/23/solution-sp1296/","excerpt":"原题目链接 首先想到$\\Theta(n^4)$的暴力枚举，但$n\\le 4000$显然不行。 考虑先预处理出c数组和d数组的和，再暴力计算答案。 由于c数组和d数组的和可能会有重复，排序后使用二分来降低时间复杂度 最终时间复杂度$\\Theta (n^2\\log n)$","text":"原题目链接 首先想到$\\Theta(n^4)$的暴力枚举，但$n\\le 4000$显然不行。 考虑先预处理出c数组和d数组的和，再暴力计算答案。 由于c数组和d数组的和可能会有重复，排序后使用二分来降低时间复杂度 最终时间复杂度$\\Theta (n^2\\log n)$ 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=4010;int n,nn,a[N],b[N],c[N],d[N],sum[N*N],ans=0;inline void read(int &amp;x)&#123; char ch=getchar(); int f=1; x=0; while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')) &#123; if(ch=='-') f=-1; ch=getchar(); &#125; do &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125;while('0'&lt;=ch&amp;&amp;ch&lt;='9'); x*=f;&#125;inline int calc(int x,int y)//降维，将二维转化成一维&#123; return (x-1)*n+y;&#125;int main()&#123; read(n); nn=n*n; for(int i=1;i&lt;=n;++i) read(a[i]),read(b[i]),read(c[i]),read(d[i]); for(int i=1;i&lt;=n;++i)//预处理出c数组和d数组的和 for(int j=1;j&lt;=n;++j) &#123; sum[calc(i,j)]=c[i]+d[j]; &#125; sort(sum+1,sum+nn+1);//排序，因为二分需要单调性 for(int i=1;i&lt;=n;++i)//暴力枚举a数组和b数组的和 &#123; for(int j=1;j&lt;=n;++j) &#123; ans+=upper_bound(sum+1,sum+nn+1,-a[i]-b[j])-lower_bound(sum+1,sum+nn+1,-a[i]-b[j]);//二分计算有多少个重复答案 &#125; &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"SPOJ","slug":"题解/SPOJ","permalink":"http://wxwoo.github.io/categories/题解/SPOJ/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://wxwoo.github.io/tags/二分/"}]},{"title":"P1791 [国家集训队]人员雇佣 题解","slug":"solution-p1791","date":"2019-04-18T16:00:00.000Z","updated":"2019-06-21T12:53:40.582Z","comments":true,"path":"2019/04/19/solution-p1791/","link":"","permalink":"http://wxwoo.github.io/2019/04/19/solution-p1791/","excerpt":"原题目链接 选人有利润，选了要付出代价：明显的最小割模型 我们将每个人看成一个点，然后如下建边： 源点向每个人连流量为其总收益的边（即$\\sum\\limits_{j=1}^n E_{i,j}$） 每个人向汇点连流量为其花费的边 $i$向$j$连流量为$E_{i,j} \\times 2$的边","text":"原题目链接 选人有利润，选了要付出代价：明显的最小割模型 我们将每个人看成一个点，然后如下建边： 源点向每个人连流量为其总收益的边（即$\\sum\\limits_{j=1}^n E_{i,j}$） 每个人向汇点连流量为其花费的边 $i$向$j$连流量为$E_{i,j} \\times 2$的边 接下来我们思考这样建边的正确性 前两条是经典的最小割模型 第三条，如果两个人都选，可以获得$E_{i,j}$的利润 如果有一个不选，会亏损$E_{i,j}$的利润 利润差为$E_{i,j} \\times 2$ 这样连边，一旦两个人中有一个人没选，这条边就会断掉，造成利润差 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;template&lt;typename T&gt; inline void read(T &amp;x)&#123; char ch=getchar(); T f=1; x=0; while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')) &#123; if(ch=='-') f=-1; ch=getchar(); &#125; while('0'&lt;=ch&amp;&amp;ch&lt;='9') &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125; x*=f;&#125;const int inf=1e9;const int N=3e5+1;struct edge&#123; int from,to,next,cap,flow;&#125;e[N];int cnt,n,m,sour,sink,head[N],ans,q[N],l[N],p[N];inline int min(int i,int j)&#123; return i&lt;j?i:j;&#125;inline void add(int u,int v,int l)&#123; e[++cnt]=(edge)&#123;u,v,head[u],l,0&#125;; head[u]=cnt; e[++cnt]=(edge)&#123;v,u,head[v],0,0&#125;; head[v]=cnt;&#125;inline bool find()&#123; memset(l,0,sizeof(l)); int h=1,t=1; q[1]=sour; l[sour]=1; while(h&lt;=t) &#123; int x=q[h++]; for(int i=head[x];i;i=e[i].next) if(!l[e[i].to]&amp;&amp;e[i].cap&gt;e[i].flow) &#123; q[++t]=e[i].to; l[e[i].to]=l[x]+1; if(e[i].to==sink) return true; &#125; &#125; return false;&#125;int dfs(int x,int now)&#123; if(x==sink||!now) return now; int t=now,detla; for(int i=head[x];i;i=e[i].next) &#123; if(e[i].cap&gt;e[i].flow&amp;&amp;l[e[i].to]==l[x]+1) &#123; detla=dfs(e[i].to,min(t,e[i].cap-e[i].flow)); if(!detla) l[e[i].to]=0; e[i].flow+=detla; e[((i-1)^1)+1].flow-=detla; t-=detla; if(t==0) break; &#125; &#125; return now-t;&#125;inline void dinic()&#123; while(find()) ans+=dfs(sour,inf);&#125;int sum;int main()&#123; read(n); sour=0; sink=n+1; int w,cost; for(int i=1;i&lt;=n;++i) &#123; read(w); add(i,sink,w); &#125; for(int i=1;i&lt;=n;++i) &#123; cost=0; for(int j=1;j&lt;=n;++j) &#123; read(w); if(w!=0)//优化：如果是0就不连边 &#123; cost+=w; add(i,j,w&lt;&lt;1); &#125; &#125; add(sour,i,cost); sum+=cost; &#125; dinic(); printf(\"%d\",sum-ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"http://wxwoo.github.io/categories/题解/洛谷/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://wxwoo.github.io/tags/网络流/"}]},{"title":"P3410 拍照 题解","slug":"solution-p3410","date":"2019-03-24T16:00:00.000Z","updated":"2019-06-21T12:55:31.553Z","comments":true,"path":"2019/03/25/solution-p3410/","link":"","permalink":"http://wxwoo.github.io/2019/03/25/solution-p3410/","excerpt":"原题目链接 每张合影可选可不选，选了必须带一些特定人：明显的最大权闭合子图 最大权闭合子图： 给定一个有向图，点有点权，选择一个子图，满足子图上如果选择了一个点就必须选择它后继的所有点。最大化点权和。 经典的网络流问题，具体使用最小割求解。","text":"原题目链接 每张合影可选可不选，选了必须带一些特定人：明显的最大权闭合子图 最大权闭合子图： 给定一个有向图，点有点权，选择一个子图，满足子图上如果选择了一个点就必须选择它后继的所有点。最大化点权和。 经典的网络流问题，具体使用最小割求解。 根据最大流最小割定理，最大流=最小割，所以这题可以使用最大流算法求解 我们将合影和人都看成一个点，然后如下建边： 源点向合影连流量为利润的边 人向汇点连流量为花费的边 每个合影向需要的人连流量为inf的边 接下来我们思考这样建边的正确性 在最小割模型中，连一条流量为$inf$的边意为连一条不可割边 那么这个图中的可割边就只有合影和人了 跑最大流（最小割）即为计算最优方案下的花费 最终答案（最大净利润）为全部合影能赚到的钱减去最小割 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int inf=1e9;const int N=3e5+1;struct edge&#123; int from,to,next,cap,flow;&#125;e[N];int cnt,n,m,sour,sink,head[N],ans,q[N],l[N],p[N];inline int min(int i,int j)&#123; return i&lt;j?i:j;&#125;inline void add(int u,int v,int l)&#123; e[++cnt]=(edge)&#123;u,v,head[u],l,0&#125;; head[u]=cnt; e[++cnt]=(edge)&#123;v,u,head[v],0,0&#125;; head[v]=cnt;&#125;inline bool find()&#123; memset(l,0,sizeof(l)); int h=1,t=1; q[1]=sour; l[sour]=1; while(h&lt;=t) &#123; int x=q[h++]; for(int i=head[x];i;i=e[i].next) if(!l[e[i].to]&amp;&amp;e[i].cap&gt;e[i].flow) &#123; q[++t]=e[i].to; l[e[i].to]=l[x]+1; if(e[i].to==sink) return true; &#125; &#125; return false;&#125;int dfs(int x,int now)&#123; if(x==sink||!now) return now; int t=now,detla; for(int i=head[x];i;i=e[i].next) &#123; if(e[i].cap&gt;e[i].flow&amp;&amp;l[e[i].to]==l[x]+1) &#123; detla=dfs(e[i].to,min(t,e[i].cap-e[i].flow)); if(!detla) l[e[i].to]=0; e[i].flow+=detla; e[((i-1)^1)+1].flow-=detla; t-=detla; if(t==0) break; &#125; &#125; return now-t;&#125;inline void dinic()&#123; while(find()) ans+=dfs(sour,inf);&#125;inline void read(int &amp;x)&#123; char ch=getchar(); int f=1; x=0; while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')) &#123; if(ch=='-') f=-1; ch=getchar(); &#125; do &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125;while('0'&lt;=ch&amp;&amp;ch&lt;='9'); x*=f;&#125;int main()&#123; read(m); read(n); int res=0; sour=0; sink=m+n+1; for(int i=1;i&lt;=m;i++) &#123; int val,x; read(val); res+=val;//计算总收益 add(sour,i,val); read(x); while(x!=0) &#123; add(i,x+m,inf); read(x); &#125; &#125; for(int i=m+1;i&lt;=n+m;i++) &#123; int val; read(val); add(i,sink,val); &#125; dinic(); printf(\"%d\",res-ans);//ans即为总花费 return 0;&#125; 双倍经验：P2762 太空飞行计划问题，快去骗经验啊qwq","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"http://wxwoo.github.io/categories/题解/洛谷/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://wxwoo.github.io/tags/网络流/"}]},{"title":"博客食用指北","slug":"introduction","date":"2019-03-21T16:00:00.000Z","updated":"2019-07-24T09:48:19.269Z","comments":true,"path":"2019/03/22/introduction/","link":"","permalink":"http://wxwoo.github.io/2019/03/22/introduction/","excerpt":"","text":"评论系统链接请填写OJ账户（luogu优先），选填邮箱用于验证和回复通知，必须填写无法匿名评论头像请用你的邮箱，到Gravatar设置由于评论管理系统尚未部署完成（其实就是咕咕咕了），不一定会发送邮件","categories":[],"tags":[]},{"title":"P2598 [ZJOI2009]狼和羊的故事 题解","slug":"solution-p2598","date":"2019-03-12T16:00:00.000Z","updated":"2019-06-21T13:09:01.822Z","comments":true,"path":"2019/03/13/solution-p2598/","link":"","permalink":"http://wxwoo.github.io/2019/03/13/solution-p2598/","excerpt":"原题目链接 将狼和羊分成两个部分：明显的最小割 根据最大流最小割定理，最大流=最小割，所以这题可以使用最大流算法求解 我们将每个格子看成一个点，然后如下建边： 源点向狼的领地连流量为$inf$的边 羊的领地向汇点连流量为$inf$的边 每个格子向上下左右四个格子连流量为$1$的边","text":"原题目链接 将狼和羊分成两个部分：明显的最小割 根据最大流最小割定理，最大流=最小割，所以这题可以使用最大流算法求解 我们将每个格子看成一个点，然后如下建边： 源点向狼的领地连流量为$inf$的边 羊的领地向汇点连流量为$inf$的边 每个格子向上下左右四个格子连流量为$1$的边 接下来我们思考这样建边的正确性 在最小割模型中，连一条流量为$inf$的边意为连一条不可割边（这套路很常见的） 那么这个图中的可割边就只有两个格子之间的边了 接下来我们考虑那些为$0$的格子 由于最小割的性质，狼和羊一定会被分成两部分，和为$0$的格子无关 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int inf=1e9;const int N=3e5+1;struct edge&#123; int from,to,next,cap,flow;&#125;e[N];int cnt,n,m,sour,sink,head[N],ans,q[N],l[N],p[N];const int move[4][2]=&#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;inline int min(int i,int j)&#123; return i&lt;j?i:j;&#125;inline void add(int u,int v,int l)&#123; e[++cnt]=(edge)&#123;u,v,head[u],l,0&#125;; head[u]=cnt; e[++cnt]=(edge)&#123;v,u,head[v],0,0&#125;; head[v]=cnt;&#125;inline bool find()&#123; memset(l,0,sizeof(l)); int h=1,t=1; q[1]=sour; l[sour]=1; while(h&lt;=t) &#123; int x=q[h++]; for(int i=head[x];i;i=e[i].next) if(!l[e[i].to]&amp;&amp;e[i].cap&gt;e[i].flow) &#123; q[++t]=e[i].to; l[e[i].to]=l[x]+1; if(e[i].to==sink) return true; &#125; &#125; return false;&#125;int dfs(int x,int now)&#123; if(x==sink||!now) return now; int t=now,detla; for(int i=head[x];i;i=e[i].next) &#123; if(e[i].cap&gt;e[i].flow&amp;&amp;l[e[i].to]==l[x]+1) &#123; detla=dfs(e[i].to,min(t,e[i].cap-e[i].flow)); if(!detla) l[e[i].to]=0; e[i].flow+=detla; e[((i-1)^1)+1].flow-=detla; t-=detla; if(t==0) break; &#125; &#125; return now-t;&#125;inline void dinic()&#123; while(find()) ans+=dfs(sour,inf);&#125;inline void read(int &amp;x)&#123; char ch; int f=1; x=0; do &#123; if(ch=='-') f=-1; ch=getchar(); &#125;while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')); do &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125;while('0'&lt;=ch&amp;&amp;ch&lt;='9'); x*=f;&#125;inline int get(int x,int y)&#123; return (x-1)*m+y;&#125;int main()&#123; read(n); read(m); sour=0; sink=n*m+1; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; int t; read(t); if(t==2) add(get(i,j),sink,inf); else if(t==1) add(sour,get(i,j),inf); for(int k=0;k&lt;4;k++) &#123; int x=i+move[k][0],y=j+move[k][1]; if(x&lt;1||x&gt;n||y&lt;1||y&gt;m) continue; add(get(i,j),get(x,y),1); &#125; &#125; &#125; dinic(); printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"http://wxwoo.github.io/categories/题解/洛谷/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://wxwoo.github.io/tags/网络流/"}]},{"title":"P1496 火烧赤壁 题解","slug":"solution-p1496","date":"2019-03-12T16:00:00.000Z","updated":"2019-04-26T08:06:49.279Z","comments":true,"path":"2019/03/13/solution-p1496/","link":"","permalink":"http://wxwoo.github.io/2019/03/13/solution-p1496/","excerpt":"原题目链接 蒟蒻提供一个思路： 理论上，我们可以将12345 ________ | __ | | | | |----------------&gt; 2 5 9 11 的重叠覆盖情况看成12345 _____ | __|__ | | | |----------------&gt; 2 5 9 11 所以，若我们将起点和终点按照从小到大的顺序排序，对答案不会产生影响","text":"原题目链接 蒟蒻提供一个思路： 理论上，我们可以将12345 ________ | __ | | | | |----------------&gt; 2 5 9 11 的重叠覆盖情况看成12345 _____ | __|__ | | | |----------------&gt; 2 5 9 11 所以，若我们将起点和终点按照从小到大的顺序排序，对答案不会产生影响例如微调样例： 3 -1 1 2 11 5 9 和原样例答案一样，都可以看成12345 __________ _ | ______|__ | | | | | |------------------------&gt; -1 1 2 5 9 11 所以，我们得到了一个解法：分别对起点和终点进行排序，循环加上每一条线段的长度，若与前一条线段重复减去重复部分 代码如下:1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; long long a[20001],b[20001],l=0;//a数组存储起点，b数组存储终点，l表示最终长度 for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]&gt;&gt;b[i];//输入 sort(a,a+n); sort(b,b+n);//由于起点终点的顺序对答案不产生影响，对a数组和b数组进行排序 for(int i=0;i&lt;n;i++) &#123; l+=b[i]-a[i];//加上当前线段长度 if(i+1&lt;n)//如果这条线段不是最后一条线段 if(b[i]&gt;a[i+1])//如果这条线段与前一条线段有重复 l-=b[i]-a[i+1];//减去重复部分 &#125; cout&lt;&lt;l;//输出 return 0;&#125; ps：蒟蒻不会离散化只能xjb模拟qwq","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"http://wxwoo.github.io/categories/题解/洛谷/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://wxwoo.github.io/tags/模拟/"}]},{"title":"SP733 MTWALK - Mountain Walking 题解","slug":"solution-sp733","date":"2019-03-12T16:00:00.000Z","updated":"2019-06-14T11:05:14.108Z","comments":true,"path":"2019/03/13/solution-sp733/","link":"","permalink":"http://wxwoo.github.io/2019/03/13/solution-sp733/","excerpt":"原题目链接 看到题目就想到了dfs+剪枝 然后就想到了dfs有问题 例如这组数据 1234-9-12| | |2-4-10 从4开始，到10结束 dfs会走$4 \\to 2 \\to 4 \\to 10$，答案为8 然而很明显走$4 \\to 9 \\to 4 \\to 10$更优，答案为6 当然你加一大堆玄学优化也是可以搜出正确答案的 这里不再多讲，而是提供另一种思路： 二分","text":"原题目链接 看到题目就想到了dfs+剪枝 然后就想到了dfs有问题 例如这组数据 1234-9-12| | |2-4-10 从4开始，到10结束 dfs会走$4 \\to 2 \\to 4 \\to 10$，答案为8 然而很明显走$4 \\to 9 \\to 4 \\to 10$更优，答案为6 当然你加一大堆玄学优化也是可以搜出正确答案的 这里不再多讲，而是提供另一种思路： 二分 $Q:$二分什么呢？ $A:$二分答案啊……这不是废话吗…… $Q:$我还不知道二分答案啊！关键是$check$函数怎么写！ $A:$这个时候我们就要祭出$dfs$大法了！ 刚才还说dfs有问题现在就用 check函数循环最小值，最大值用最小值+答案计算出 对整张表dfs，标记数值在最小值到最大值区间内的格子 若目标点被标记，返回true，否则继续循环，直到循环结束，返回false 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=110,move[4][2]=&#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;int m[N][N],n,ans=0;bool visit[N][N];template&lt;typename T&gt;inline void read(T &amp;x)//快读&#123; char ch=getchar(); T f=1; x=0; while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')) &#123; if(ch=='-') f=-1; ch=getchar(); &#125; do &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125;while('0'&lt;=ch&amp;&amp;ch&lt;='9'); x*=f;&#125;void dfs(int x,int y,const int&amp; sml,const int&amp; big)//sml即为最小值，big即为最大值&#123;//dfs板子，不作过多解释 if(visit[x][y]) return; visit[x][y]=true; for(int i=0;i&lt;4;i++) &#123; int nx=x+move[i][0],ny=y+move[i][1]; if(nx&lt;1||nx&gt;n||ny&lt;1||ny&gt;n) continue; if(m[nx][ny]&lt;sml||m[nx][ny]&gt;big)//若不在最小值到最大值区间内，则continue continue; dfs(nx,ny,sml,big); &#125;&#125;inline bool check(int x)//x即为要检验的答案&#123; for(int i=max(0,max(m[1][1],m[n][n])-x);i&lt;=min(110-x,min(m[1][1],m[n][n]));i++) //最小值的初值：从起点和终点里取最大的（不然其中一个点必然不被标记），减去x，并且不为负数（和0取max） //退出循环判断：从起点和终点里取最小的（不然其中一个点必然不被标记），并和110-x取最小值（不然最大值就超出数据范围了），如果i大于这个值，则退出循环 &#123; memset(visit,0,sizeof(visit)); dfs(1,1,i,x+i);//i为最小值，x+i为最大值 if(visit[n][n])//如果终点被标记，则返回true return true; &#125; return false;//若所有区间均尝试过仍没有返回，则返回false&#125;int main()&#123; read(n); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) read(m[i][j]); int l=0,r=N;//二分模板 while(l&lt;=r) &#123; int mid=l+r&gt;&gt;1; if(check(mid)) &#123; ans=mid; r=mid-1; &#125; else l=mid+1; &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"SPOJ","slug":"题解/SPOJ","permalink":"http://wxwoo.github.io/categories/题解/SPOJ/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://wxwoo.github.io/tags/二分/"}]},{"title":"CF1108A Two distinct points 题解","slug":"solution-cf1108a","date":"2019-03-12T16:00:00.000Z","updated":"2019-06-01T03:27:16.206Z","comments":true,"path":"2019/03/13/solution-cf1108a/","link":"","permalink":"http://wxwoo.github.io/2019/03/13/solution-cf1108a/","excerpt":"原题目链接 我们可以取两条线段的中点，若重合就让第二条线段的中点+1 $Q:$中点+1后不在线段上怎么办？ $A:$由于C++整数除法自动省略小数，也就是向下取整，若线段长度大于1，那么中点+1后一定不会超出线段，若线段长度为1，即$l+1=r$，那么$\\left\\lfloor\\dfrac{l+r}{2}\\right\\rfloor=l$，所以中点$+1=r$，也不会超出线段，所以中点+1后无论如何都在线段上，符合题意","text":"原题目链接 我们可以取两条线段的中点，若重合就让第二条线段的中点+1 $Q:$中点+1后不在线段上怎么办？ $A:$由于C++整数除法自动省略小数，也就是向下取整，若线段长度大于1，那么中点+1后一定不会超出线段，若线段长度为1，即$l+1=r$，那么$\\left\\lfloor\\dfrac{l+r}{2}\\right\\rfloor=l$，所以中点$+1=r$，也不会超出线段，所以中点+1后无论如何都在线段上，符合题意 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;inline void read(int &amp;x)//快读，写不写无所谓&#123; char ch; int f=1; x=0; do &#123; if(ch=='-') f=-1; ch=getchar(); &#125;while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')); do &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125;while('0'&lt;=ch&amp;&amp;ch&lt;='9'); x*=f;&#125;int main()&#123; int q; read(q);//读入q while(q--)//循环q次，可换成for(int i=1;i&lt;=q;i++) &#123; int l1,r1,l2,r2; read(l1); read(r1); read(l2); read(r2);//读入l1,r1,l2,r2 int a=(l1+r1)/2; int b=(l2+r2)/2;//取两条线段的中点 printf(\"%d %d\\n\",a,(a==b?b+1:b));//若相等，输出b+1，反之输出b &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"codeforces","slug":"题解/codeforces","permalink":"http://wxwoo.github.io/categories/题解/codeforces/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://wxwoo.github.io/tags/模拟/"}]},{"title":"P3965 [TJOI2013]循环格 题解","slug":"solution-p3965","date":"2019-03-12T16:00:00.000Z","updated":"2019-06-21T12:56:42.925Z","comments":true,"path":"2019/03/13/solution-p3965/","link":"","permalink":"http://wxwoo.github.io/2019/03/13/solution-p3965/","excerpt":"原题目链接 洛谷随机跳题跳到的 有指向，有修改，求最小：明显的最小费用最大流 我们将每个格子看成一个点，然后拆点，如下建边： 源点向每个点连边，流量为1，费用为0 每个点的拆点向汇点连边，流量为1，费用为0 每个点向四周的点连边，流量为1，默认指向费用为0，其他为1","text":"原题目链接 洛谷随机跳题跳到的 有指向，有修改，求最小：明显的最小费用最大流 我们将每个格子看成一个点，然后拆点，如下建边： 源点向每个点连边，流量为1，费用为0 每个点的拆点向汇点连边，流量为1，费用为0 每个点向四周的点连边，流量为1，默认指向费用为0，其他为1 下面我们思考这样建边的正确性 根据最小费用最大流的性质，一定会优先费用为0的边（也就是默认指向） 由于每条边流量都是1，所以不存在一个点有两个指向这种情况 ps：3，4数据点疑似在Windows下生成，使用getchar()要注意对\\r的判断 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define inf 1e9const int N=3e5+1;struct edge&#123; int from,to,next,cap,flow,cost;&#125;e[N];bool vis[N];int cnt,n,m,sour,sink,head[N],ans,cost,q[N],p[N],d[N],h,t;const int move[4][2]=&#123;-1,0,1,0,0,-1,0,1&#125;;inline void add(int u,int v,int l,int f)&#123; e[++cnt]=(edge)&#123;u,v,head[u],l,0,f&#125;; head[u]=cnt; e[++cnt]=(edge)&#123;v,u,head[v],0,0,-f&#125;; head[v]=cnt;&#125;inline void augment()&#123; int detla=inf,c=0; for(int i=sink;i!=sour;i=e[p[i]].from) &#123; detla=min(detla,e[p[i]].cap-e[p[i]].flow); c+=e[p[i]].cost; &#125; for(int i=sink;i!=sour;i=e[p[i]].from) &#123; e[p[i]].flow+=detla; e[((p[i]-1)^1)+1].flow-=detla; &#125; ans+=detla; cost+=detla*c;&#125;inline bool find()&#123; memset(d,127,sizeof(d)); memset(vis,0,sizeof(vis)); vis[sour]=true; d[sour]=0; q[h=t=1]=sour; while(h&lt;=t) &#123; int x=q[h++]; vis[x]=false; for(int i=head[x];i;i=e[i].next) &#123; if(e[i].cap&gt;e[i].flow&amp;&amp;d[x]+e[i].cost&lt;d[e[i].to]) &#123; if(!vis[e[i].to]) &#123; vis[e[i].to]=true; q[++t]=e[i].to; &#125; d[e[i].to]=d[x]+e[i].cost; p[e[i].to]=i; &#125; &#125; &#125; return d[sink]&lt;inf;&#125;inline void sap()&#123; while(find()) augment();&#125;inline void read(int &amp;x)&#123; char ch; int f=1; x=0; do &#123; if(ch=='-') f=-1; ch=getchar(); &#125;while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')); do &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125;while('0'&lt;=ch&amp;&amp;ch&lt;='9'); x*=f;&#125;inline int get(int x,int y)&#123; return (x-1)*m+y;&#125;int main()&#123; read(n); read(m); sour=0; sink=2*n*m+1; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; char c; cin&gt;&gt;c; int dir; add(sour,get(i,j),1,0); add(get(i,j)+n*m,sink,1,0); if(c=='U') dir=0; else if(c=='D') dir=1; else if(c=='L') dir=2; else if(c=='R') dir=3; for(int k=0;k&lt;4;k++) &#123; int x=i+move[k][0],y=j+move[k][1]; if(x==n+1) x=1; else if(x==0) x=n; if(y==m+1) y=1; else if(y==0) y=m; if(dir==k) add(get(i,j),get(x,y)+n*m,1,0); else add(get(i,j),get(x,y)+n*m,1,1); &#125; &#125; &#125; sap(); printf(\"%d\",cost); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"http://wxwoo.github.io/categories/题解/洛谷/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://wxwoo.github.io/tags/网络流/"}]},{"title":"CF743A Vladik and flights 题解","slug":"solution-cf743a","date":"2019-03-12T16:00:00.000Z","updated":"2019-04-26T08:05:39.732Z","comments":true,"path":"2019/03/13/solution-cf743a/","link":"","permalink":"http://wxwoo.github.io/2019/03/13/solution-cf743a/","excerpt":"原题目链接 写这题翻译的时候，突然就有了思路 实际上这题重在思考 若a机场和b机场是同一家公司，输出0，这个很容易想到 若a机场和b机场不是同一家公司，输出1，这是为什么呢？","text":"原题目链接 写这题翻译的时候，突然就有了思路 实际上这题重在思考 若a机场和b机场是同一家公司，输出0，这个很容易想到 若a机场和b机场不是同一家公司，输出1，这是为什么呢？ 首先，一定有两个不同公司的机场相邻 我们设这两个机场为$i$和$j$，且$i$与$a$同公司，$j$与$b$同公司 那么就有如下航线： a\\to i\\to j\\to b由于i与j相邻且不为同一家公司，所以总费用为1 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt; inline void read(T &amp;x)//快读&#123; char ch; T f=1; x=0; do &#123; if(ch=='-') f=-1; ch=getchar(); &#125;while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')); do &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125;while('0'&lt;=ch&amp;&amp;ch&lt;='9'); x*=f;&#125;int n,a,b;int f[100010];int main()&#123; read(n); read(a); read(b);//输入n,a,b for(int i=1;i&lt;=n;i++) &#123; char c=getchar(); f[i]=c-48;//输入公司 &#125; if(f[a]==f[b])//如果公司相同 putchar('0');//输出0 else//如果公司不同 putchar('1');//输出1 return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"codeforces","slug":"题解/codeforces","permalink":"http://wxwoo.github.io/categories/题解/codeforces/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://wxwoo.github.io/tags/模拟/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-03-12T15:30:33.758Z","updated":"2019-03-13T09:59:18.010Z","comments":true,"path":"2019/03/12/hello-world/","link":"","permalink":"http://wxwoo.github.io/2019/03/12/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}