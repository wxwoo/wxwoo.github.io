{"meta":{"title":"wxwoo's blog","subtitle":null,"description":null,"author":"wxwoo","url":"http://wxwoo.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2019-03-19T10:43:52.542Z","updated":"2019-03-19T10:43:52.542Z","comments":true,"path":"categories/index.html","permalink":"http://wxwoo.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-03-19T10:43:50.112Z","updated":"2019-03-19T10:43:50.112Z","comments":true,"path":"tags/index.html","permalink":"http://wxwoo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SP1296 SUMFOUR - 4 values whose sum is 0 题解","slug":"solution-sp1296","date":"2019-04-22T16:00:00.000Z","updated":"2019-04-26T08:08:29.463Z","comments":true,"path":"2019/04/23/solution-sp1296/","link":"","permalink":"http://wxwoo.github.io/2019/04/23/solution-sp1296/","excerpt":"原题目链接 首先想到$\\Theta(n^4)$的暴力枚举，但$n\\le 4000$显然不行。 考虑先预处理出c数组和d数组的和，再暴力计算答案。 由于c数组和d数组的和可能会有重复，排序后使用二分来降低时间复杂度 最终时间复杂度$\\Theta (n^2\\log n)$","text":"原题目链接 首先想到$\\Theta(n^4)$的暴力枚举，但$n\\le 4000$显然不行。 考虑先预处理出c数组和d数组的和，再暴力计算答案。 由于c数组和d数组的和可能会有重复，排序后使用二分来降低时间复杂度 最终时间复杂度$\\Theta (n^2\\log n)$ 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=4010;int n,nn,a[N],b[N],c[N],d[N],sum[N*N],ans=0;inline void read(int &amp;x)&#123; char ch=getchar(); int f=1; x=0; while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')) &#123; if(ch=='-') f=-1; ch=getchar(); &#125; do &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125;while('0'&lt;=ch&amp;&amp;ch&lt;='9'); x*=f;&#125;inline int calc(int x,int y)//降维，将二维转化成一维&#123; return (x-1)*n+y;&#125;int main()&#123; read(n); nn=n*n; for(int i=1;i&lt;=n;++i) read(a[i]),read(b[i]),read(c[i]),read(d[i]); for(int i=1;i&lt;=n;++i)//预处理出c数组和d数组的和 for(int j=1;j&lt;=n;++j) &#123; sum[calc(i,j)]=c[i]+d[j]; &#125; sort(sum+1,sum+nn+1);//排序，因为二分需要单调性 for(int i=1;i&lt;=n;++i)//暴力枚举a数组和b数组的和 &#123; for(int j=1;j&lt;=n;++j) &#123; ans+=upper_bound(sum+1,sum+nn+1,-a[i]-b[j])-lower_bound(sum+1,sum+nn+1,-a[i]-b[j]);//二分计算有多少个重复答案 &#125; &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"SPOJ","slug":"题解/SPOJ","permalink":"http://wxwoo.github.io/categories/题解/SPOJ/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://wxwoo.github.io/tags/二分/"}]},{"title":"P1791 [国家集训队]人员雇佣 题解","slug":"solution-p1791","date":"2019-04-18T16:00:00.000Z","updated":"2019-04-26T08:07:26.167Z","comments":true,"path":"2019/04/19/solution-p1791/","link":"","permalink":"http://wxwoo.github.io/2019/04/19/solution-p1791/","excerpt":"原题目链接 选人有利润，选了要付出代价：明显的最小割模型 我们将每个人看成一个点，然后如下建边： 原点向每个人连流量为其总收益的边（即$\\sum\\limits_{j=1}^n E_{i,j}$） 每个人向汇点连流量为其花费的边 i向j连流量为$E_{i,j} \\times 2$的边","text":"原题目链接 选人有利润，选了要付出代价：明显的最小割模型 我们将每个人看成一个点，然后如下建边： 原点向每个人连流量为其总收益的边（即$\\sum\\limits_{j=1}^n E_{i,j}$） 每个人向汇点连流量为其花费的边 i向j连流量为$E_{i,j} \\times 2$的边 接下来我们思考这样建边的正确性 前两条是经典的最小割模型 第三条，如果两个人都选，可以获得$E_{i,j}$的利润 如果有一个不选，会亏损$E_{i,j}$的利润 利润差为$E_{i,j} \\times 2$ 这样连边，一旦两个人中有一个人没选，这条边就会断掉，造成利润差 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;template&lt;typename T&gt; inline void read(T &amp;x)&#123; char ch=getchar(); T f=1; x=0; while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')) &#123; if(ch=='-') f=-1; ch=getchar(); &#125; while('0'&lt;=ch&amp;&amp;ch&lt;='9') &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125; x*=f;&#125;const int inf=1e9;const int N=3e5+1;struct edge&#123; int from,to,next,cap,flow;&#125;e[N];int cnt,n,m,sour,sink,head[N],ans,q[N],l[N],p[N];inline int min(int i,int j)&#123; return i&lt;j?i:j;&#125;inline void add(int u,int v,int l)&#123; e[++cnt]=(edge)&#123;u,v,head[u],l,0&#125;; head[u]=cnt; e[++cnt]=(edge)&#123;v,u,head[v],0,0&#125;; head[v]=cnt;&#125;inline bool find()&#123; memset(l,0,sizeof(l)); int h=1,t=1; q[1]=sour; l[sour]=1; while(h&lt;=t) &#123; int x=q[h++]; for(int i=head[x];i;i=e[i].next) if(!l[e[i].to]&amp;&amp;e[i].cap&gt;e[i].flow) &#123; q[++t]=e[i].to; l[e[i].to]=l[x]+1; if(e[i].to==sink) return true; &#125; &#125; return false;&#125;int dfs(int x,int now)&#123; if(x==sink||!now) return now; int t=now,detla; for(int i=head[x];i;i=e[i].next) &#123; if(e[i].cap&gt;e[i].flow&amp;&amp;l[e[i].to]==l[x]+1) &#123; detla=dfs(e[i].to,min(t,e[i].cap-e[i].flow)); if(!detla) l[e[i].to]=0; e[i].flow+=detla; e[((i-1)^1)+1].flow-=detla; t-=detla; if(t==0) break; &#125; &#125; return now-t;&#125;inline void dinic()&#123; while(find()) ans+=dfs(sour,inf);&#125;int sum;int main()&#123; read(n); sour=0; sink=n+1; int w,cost; for(int i=1;i&lt;=n;++i) &#123; read(w); add(i,sink,w); &#125; for(int i=1;i&lt;=n;++i) &#123; cost=0; for(int j=1;j&lt;=n;++j) &#123; read(w); if(w!=0)//优化：如果是0就不连边 &#123; cost+=w; add(i,j,w&lt;&lt;1); &#125; &#125; add(sour,i,cost); sum+=cost; &#125; dinic(); printf(\"%d\",sum-ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"http://wxwoo.github.io/categories/题解/洛谷/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://wxwoo.github.io/tags/网络流/"}]},{"title":"P3410 拍照 题解","slug":"solution-p3410","date":"2019-03-24T16:00:00.000Z","updated":"2019-04-26T08:08:02.839Z","comments":true,"path":"2019/03/25/solution-p3410/","link":"","permalink":"http://wxwoo.github.io/2019/03/25/solution-p3410/","excerpt":"原题目链接 每张合影可选可不选，选了必须带一些特定人：明显的最大权闭合子图 最大权闭合子图： 给定一个有向图，点有点权，选择一个子图，满足子图上如果选择了一个点就必须选择它后继的所有点。最大化点权和。 经典的网络流问题，具体使用最小割求解。","text":"原题目链接 每张合影可选可不选，选了必须带一些特定人：明显的最大权闭合子图 最大权闭合子图： 给定一个有向图，点有点权，选择一个子图，满足子图上如果选择了一个点就必须选择它后继的所有点。最大化点权和。 经典的网络流问题，具体使用最小割求解。 根据最大流最小割定理，最大流=最小割，所以这题可以使用最大流算法求解 我们将合影和人都看成一个点，然后如下建边： 原点向合影连流量为利润的边 人向汇点连流量为花费的边 每个合影向需要的人连流量为inf的边 接下来我们思考这样建边的正确性 在最小割模型中，连一条流量为inf的边意为连一条不可割边 (这套路很常见的) 那么这个图中的可割边就只有合影和人了 跑最大流（最小割）即为计算最优方案下的花费 最终答案为全部合影能赚到的钱减去最小割（即为花费） 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int inf=1e9;const int N=3e5+1;struct edge&#123; int from,to,next,cap,flow;&#125;e[N];int cnt,n,m,sour,sink,head[N],ans,q[N],l[N],p[N];inline int min(int i,int j)&#123; return i&lt;j?i:j;&#125;inline void add(int u,int v,int l)&#123; e[++cnt]=(edge)&#123;u,v,head[u],l,0&#125;; head[u]=cnt; e[++cnt]=(edge)&#123;v,u,head[v],0,0&#125;; head[v]=cnt;&#125;inline bool find()&#123; memset(l,0,sizeof(l)); int h=1,t=1; q[1]=sour; l[sour]=1; while(h&lt;=t) &#123; int x=q[h++]; for(int i=head[x];i;i=e[i].next) if(!l[e[i].to]&amp;&amp;e[i].cap&gt;e[i].flow) &#123; q[++t]=e[i].to; l[e[i].to]=l[x]+1; if(e[i].to==sink) return true; &#125; &#125; return false;&#125;int dfs(int x,int now)&#123; if(x==sink||!now) return now; int t=now,detla; for(int i=head[x];i;i=e[i].next) &#123; if(e[i].cap&gt;e[i].flow&amp;&amp;l[e[i].to]==l[x]+1) &#123; detla=dfs(e[i].to,min(t,e[i].cap-e[i].flow)); if(!detla) l[e[i].to]=0; e[i].flow+=detla; e[((i-1)^1)+1].flow-=detla; t-=detla; if(t==0) break; &#125; &#125; return now-t;&#125;inline void dinic()&#123; while(find()) ans+=dfs(sour,inf);&#125;inline void read(int &amp;x)&#123; char ch=getchar(); int f=1; x=0; while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')) &#123; if(ch=='-') f=-1; ch=getchar(); &#125; do &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125;while('0'&lt;=ch&amp;&amp;ch&lt;='9'); x*=f;&#125;int main()&#123; read(m); read(n); int res=0; sour=0; sink=m+n+1; for(int i=1;i&lt;=m;i++) &#123; int val,x; read(val); res+=val;//计算总收益 add(sour,i,val); read(x); while(x!=0) &#123; add(i,x+m,inf); read(x); &#125; &#125; for(int i=m+1;i&lt;=n+m;i++) &#123; int val; read(val); add(i,sink,val); &#125; dinic(); printf(\"%d\",res-ans);//ans即为总花费 return 0;&#125; 双倍经验：P2762 太空飞行计划问题，快去骗经验啊qwq","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"http://wxwoo.github.io/categories/题解/洛谷/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://wxwoo.github.io/tags/网络流/"}]},{"title":"博客食用指北","slug":"introduction","date":"2019-03-21T16:00:00.000Z","updated":"2019-04-02T14:24:50.473Z","comments":true,"path":"2019/03/22/introduction/","link":"","permalink":"http://wxwoo.github.io/2019/03/22/introduction/","excerpt":"","text":"评论系统链接请填写OJ账户（luogu优先），选填邮箱用于验证和回复通知，必须填写无法匿名评论头像请用你的邮箱，到gravatar设置 由于评论系统尚不完善，邮件回复仍在调试，暂时不会发送邮件，该BUG正在修复中","categories":[],"tags":[]},{"title":"P1496 火烧赤壁 题解","slug":"solution-p1496","date":"2019-03-12T16:00:00.000Z","updated":"2019-04-26T08:06:49.279Z","comments":true,"path":"2019/03/13/solution-p1496/","link":"","permalink":"http://wxwoo.github.io/2019/03/13/solution-p1496/","excerpt":"原题目链接 蒟蒻提供一个思路： 理论上，我们可以将12345 ________ | __ | | | | |----------------&gt; 2 5 9 11 的重叠覆盖情况看成12345 _____ | __|__ | | | |----------------&gt; 2 5 9 11 所以，若我们将起点和终点按照从小到大的顺序排序，对答案不会产生影响","text":"原题目链接 蒟蒻提供一个思路： 理论上，我们可以将12345 ________ | __ | | | | |----------------&gt; 2 5 9 11 的重叠覆盖情况看成12345 _____ | __|__ | | | |----------------&gt; 2 5 9 11 所以，若我们将起点和终点按照从小到大的顺序排序，对答案不会产生影响例如微调样例： 3 -1 1 2 11 5 9 和原样例答案一样，都可以看成12345 __________ _ | ______|__ | | | | | |------------------------&gt; -1 1 2 5 9 11 所以，我们得到了一个解法：分别对起点和终点进行排序，循环加上每一条线段的长度，若与前一条线段重复减去重复部分 代码如下:1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; long long a[20001],b[20001],l=0;//a数组存储起点，b数组存储终点，l表示最终长度 for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]&gt;&gt;b[i];//输入 sort(a,a+n); sort(b,b+n);//由于起点终点的顺序对答案不产生影响，对a数组和b数组进行排序 for(int i=0;i&lt;n;i++) &#123; l+=b[i]-a[i];//加上当前线段长度 if(i+1&lt;n)//如果这条线段不是最后一条线段 if(b[i]&gt;a[i+1])//如果这条线段与前一条线段有重复 l-=b[i]-a[i+1];//减去重复部分 &#125; cout&lt;&lt;l;//输出 return 0;&#125; ps：蒟蒻不会离散化只能xjb模拟qwq","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"http://wxwoo.github.io/categories/题解/洛谷/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://wxwoo.github.io/tags/模拟/"}]},{"title":"P1540 机器翻译 题解","slug":"solution-p1540","date":"2019-03-12T16:00:00.000Z","updated":"2019-04-26T08:07:10.243Z","comments":true,"path":"2019/03/13/solution-p1540/","link":"","permalink":"http://wxwoo.github.io/2019/03/13/solution-p1540/","excerpt":"原题目链接 蒟蒻的思路 使用一个数组存储新出现的单词 如果这个数组的最后m个单词里有当前单词代表内存里有当前单词 反之则没有，将当前单词存入数组","text":"原题目链接 蒟蒻的思路 使用一个数组存储新出现的单词 如果这个数组的最后m个单词里有当前单词代表内存里有当前单词 反之则没有，将当前单词存入数组 代码如下 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int m,n,q[100010],cur,count,num;//cur表示当前单词,count表示外存查询次数，q模拟内存，num表示q数组最后一个数的下标bool flag=false;int main()&#123; memset(q,-1,sizeof(q));//由于数据范围是0&lt;=单词&lt;=1000，所以这里把q更改为-1 cin&gt;&gt;m&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; flag=0;//初始化标记 cin&gt;&gt;cur; for(int i=(num-m&lt;0?0:num-m);i&lt;=num;i++)//对当前数组中最后m个元素进行查找，若不够m个则对数组中所有元素进行查找 &#123; if(q[i]==cur)//若有相同单词 &#123; flag=true;//标记 break;//退出查找 &#125; &#125; if(flag)//如果有 &#123; continue;//跳过当前循环 &#125; else//如果没有 &#123; count++;//外存查找单词，计数+1 q[num++]=cur;//存入内存 &#125; &#125; cout&lt;&lt;count; return 0;&#125; ps：这不是队列吗？ 附：memset的使用方法 需要：1#include&lt;cstring&gt; 或1#include&lt;bits/stdc++.h&gt; 用法：1memset(数组名称,要替换成的值,sizeof(数组名称)); 作用：将该数组内所有值替换为要替换的值 其中数组不一定是int，也可以是char bool double等等 例如刚才那篇代码中的1memset(q,-1,sizeof(q)); 等价于1234for(int i=0;i&lt;100010;i++)&#123; q[i]=-1;&#125; 还有一种思路 既然单词是先进后出自然可以想到队列 这里使用遍历队列的方式查询内存中有没有当前单词 C++自带STL队列，部分功能： 1234567queue&lt;int&gt; q;//定义一个int型队列qq.size();//返回当前队列内元素个数q.front();//返回队首元素q.back();//返回队尾元素q.empty();//返回队列是否为空q.push(x);//将x压入队尾q.pop();//弹出队首元素 话不多说上AC代码 我说的还少吗12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;using namespace std;queue&lt;int&gt; q;//定义队列qint main()&#123; int m,n,cur,count=0;//同上 bool flag=false; cin&gt;&gt;m&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;cur; flag=0; for(int j=1;j&lt;=q.size();j++)//遍历队列 &#123; if(q.front()==cur)//如果有相同的 &#123; q.push(q.front());//队首出队，入队 q.pop(); flag=1;//标记 //ps：由于这里使用队列模拟内存，顺序极其重要，所以不能像前一篇退出循环 &#125; else &#123; q.push(q.front());//若没有，将队首出队，入队尾 q.pop(); &#125; &#125; if(flag)//如果标记为真，表示内存有当前单词 continue;//跳过当前循环 else//如果内存没有 &#123; if(q.size()&lt;m)//如果内存不满 q.push(cur);//入队 else//如果内存已满 &#123; q.pop();//将队首出队 q.push(cur);//入队 &#125; count++;//外存查找单词，计数+1 &#125; &#125; cout&lt;&lt;count; return 0;&#125; 还有一种思路 用一个bool数组标记在内存中的单词 再使用队列模拟内存 由于不需要遍历队列 所以这种方法理论上时间复杂度比前两种低 由于这题数据范围较小 所以前两种也不会超时 代码如下：1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;bool flag[1010];//在内存中的单词queue&lt;int&gt; q;//同上int main()&#123; int m,n,count,cur;//同上 cin&gt;&gt;m&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;cur; if(flag[cur])//如果内存中有当前单词 &#123; continue;//跳过循环 &#125; else//内存中没有当前单词 &#123; flag[cur]++;//将当前单词存入内存 if(q.size&gt;=m)//如果内存已满 &#123; flag[q.front()]--;//弹出队首单词 q.pop();//弹出队首单词 &#125; q.push(cur);//将当前单词存入队列 count++;//外存查找单词，计数+1 &#125; &#125; cout&lt;&lt;count; return 0;&#125; ps：这三种方法有区别吗？","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"http://wxwoo.github.io/categories/题解/洛谷/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://wxwoo.github.io/tags/模拟/"}]},{"title":"SP733 MTWALK - Mountain Walking 题解","slug":"solution-sp733","date":"2019-03-12T16:00:00.000Z","updated":"2019-04-26T08:08:45.007Z","comments":true,"path":"2019/03/13/solution-sp733/","link":"","permalink":"http://wxwoo.github.io/2019/03/13/solution-sp733/","excerpt":"原题目链接 看到题目就想到了dfs+剪枝 然后就想到了dfs有问题 例如这组数据 1234-9| |2-4-10 从4开始，到10结束 dfs会走$4 \\to 2 \\to 4 \\to 10$，答案为8 然而很明显走$4 \\to 9 \\to 4 \\to 10$更优，答案为6 当然你加一大堆玄学优化也是可以搜出正确答案的 这里不再多讲，而是提供另一种思路： 二分","text":"原题目链接 看到题目就想到了dfs+剪枝 然后就想到了dfs有问题 例如这组数据 1234-9| |2-4-10 从4开始，到10结束 dfs会走$4 \\to 2 \\to 4 \\to 10$，答案为8 然而很明显走$4 \\to 9 \\to 4 \\to 10$更优，答案为6 当然你加一大堆玄学优化也是可以搜出正确答案的 这里不再多讲，而是提供另一种思路： 二分 Q:二分什么呢？ A:二分答案啊……这不是废话吗…… Q:我还不知道二分答案啊！关键是check函数怎么写！ A:这个时候我们就要祭出dfs大法了！ 刚才还说dfs有问题现在就用 check函数循环最小值，最大值用最小值+答案计算出 对整张表dfs，标记数值在最小值到最大值区间内的格子 若目标点被标记，返回true，否则继续循环，直到没有时，返回false 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=110,move[4][2]=&#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;int m[N][N],n,ans=0;bool visit[N][N];template&lt;typename T&gt;inline void read(T &amp;x)//快读&#123; char ch=getchar(); T f=1; x=0; while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')) &#123; if(ch=='-') f=-1; ch=getchar(); &#125; do &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125;while('0'&lt;=ch&amp;&amp;ch&lt;='9'); x*=f;&#125;void dfs(int x,int y,const int&amp; sml,const int&amp; big)//sml即为最小值，big即为最大值&#123;//dfs板子，不作过多解释 if(visit[x][y]) return; visit[x][y]=true; for(int i=0;i&lt;4;i++) &#123; int nx=x+move[i][0],ny=y+move[i][1]; if(nx&lt;1||nx&gt;n||ny&lt;1||ny&gt;n) continue; if(m[nx][ny]&lt;sml||m[nx][ny]&gt;big)//若不在最小值到最大值区间内，则continue continue; dfs(nx,ny,sml,big); &#125;&#125;inline bool check(int x)//x即为要检验的答案&#123; for(int i=max(0,max(m[1][1],m[n][n])-x);i&lt;=min(110-x,min(m[1][1],m[n][n]));i++) //最小值的初值：从起点和终点里取最大的（不然其中一个点必然不被标记），减去x，并且不为负数（和0取max） //退出循环判断：从起点和终点里取最小的（不然其中一个点必然不被标记），并和110-x取最小值（不然最大值就超出数据范围了），如果i大于这个值，则退出循环 &#123; memset(visit,0,sizeof(visit)); dfs(1,1,i,x+i);//i为最小值，x+i为最大值 if(visit[n][n])//如果终点被标记，则返回true return true; &#125; return false;//若所有区间均尝试过仍没有返回，则返回false&#125;int main()&#123; read(n); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) read(m[i][j]); int l=0,r=N;//二分模板 while(l&lt;=r) &#123; int mid=l+r&gt;&gt;1; if(check(mid)) &#123; ans=mid; r=mid-1; &#125; else l=mid+1; &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"SPOJ","slug":"题解/SPOJ","permalink":"http://wxwoo.github.io/categories/题解/SPOJ/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://wxwoo.github.io/tags/二分/"}]},{"title":"P2598 [ZJOI2009]狼和羊的故事 题解","slug":"solution-p2598","date":"2019-03-12T16:00:00.000Z","updated":"2019-04-26T08:07:46.391Z","comments":true,"path":"2019/03/13/solution-p2598/","link":"","permalink":"http://wxwoo.github.io/2019/03/13/solution-p2598/","excerpt":"原题目链接 将狼和羊分成两个部分：明显的最小割 根据最大流最小割定理，最大流=最小割，所以这题可以使用最大流算法求解 我们将每个格子看成一个点，然后如下建边： 原点向狼的领地连流量为inf的边 羊的领地向汇点连流量为inf的边 每个格子向上下左右四个格子连流量为1的边","text":"原题目链接 将狼和羊分成两个部分：明显的最小割 根据最大流最小割定理，最大流=最小割，所以这题可以使用最大流算法求解 我们将每个格子看成一个点，然后如下建边： 原点向狼的领地连流量为inf的边 羊的领地向汇点连流量为inf的边 每个格子向上下左右四个格子连流量为1的边 接下来我们思考这样建边的正确性 在最小割模型中，连一条流量为$inf$的边意为连一条不可割边 (这套路很常见的) 那么这个图中的可割边就只有两个格子之间的边了 接下来我们考虑那些为$0$的格子 由于最小割的性质，狼和羊一定会被分成两部分，和为$0$的格子无关 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int inf=1e9;const int N=3e5+1;struct edge&#123; int from,to,next,cap,flow;&#125;e[N];int cnt,n,m,sour,sink,head[N],ans,q[N],l[N],p[N];const int move[4][2]=&#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;inline int min(int i,int j)&#123; return i&lt;j?i:j;&#125;inline void add(int u,int v,int l)&#123; e[++cnt]=(edge)&#123;u,v,head[u],l,0&#125;; head[u]=cnt; e[++cnt]=(edge)&#123;v,u,head[v],0,0&#125;; head[v]=cnt;&#125;inline bool find()&#123; memset(l,0,sizeof(l)); int h=1,t=1; q[1]=sour; l[sour]=1; while(h&lt;=t) &#123; int x=q[h++]; for(int i=head[x];i;i=e[i].next) if(!l[e[i].to]&amp;&amp;e[i].cap&gt;e[i].flow) &#123; q[++t]=e[i].to; l[e[i].to]=l[x]+1; if(e[i].to==sink) return true; &#125; &#125; return false;&#125;int dfs(int x,int now)&#123; if(x==sink||!now) return now; int t=now,detla; for(int i=head[x];i;i=e[i].next) &#123; if(e[i].cap&gt;e[i].flow&amp;&amp;l[e[i].to]==l[x]+1) &#123; detla=dfs(e[i].to,min(t,e[i].cap-e[i].flow)); if(!detla) l[e[i].to]=0; e[i].flow+=detla; e[((i-1)^1)+1].flow-=detla; t-=detla; if(t==0) break; &#125; &#125; return now-t;&#125;inline void dinic()&#123; while(find()) ans+=dfs(sour,inf);&#125;inline void read(int &amp;x)&#123; char ch; int f=1; x=0; do &#123; if(ch=='-') f=-1; ch=getchar(); &#125;while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')); do &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125;while('0'&lt;=ch&amp;&amp;ch&lt;='9'); x*=f;&#125;inline int get(int x,int y)&#123; return (x-1)*m+y;&#125;int main()&#123; read(n); read(m); sour=0; sink=n*m+1; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; int t; read(t); if(t==2) add(get(i,j),sink,inf); else if(t==1) add(sour,get(i,j),inf); for(int k=0;k&lt;4;k++) &#123; int x=i+move[k][0],y=j+move[k][1]; if(x&lt;1||x&gt;n||y&lt;1||y&gt;m) continue; add(get(i,j),get(x,y),1); &#125; &#125; &#125; dinic(); printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"http://wxwoo.github.io/categories/题解/洛谷/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://wxwoo.github.io/tags/网络流/"}]},{"title":"CF1108A Two distinct points 题解","slug":"solution-cf1108a","date":"2019-03-12T16:00:00.000Z","updated":"2019-04-26T08:05:12.880Z","comments":true,"path":"2019/03/13/solution-cf1108a/","link":"","permalink":"http://wxwoo.github.io/2019/03/13/solution-cf1108a/","excerpt":"原题目链接 我们可以取两条线段的中点，若重合就让第二条线段的中点+1 Q:中点+1后不在线段上怎么办？ A:由于C++整数除法自动省略小数，也就是向下取整，若线段长度为1，即l+1=r，那么$\\left\\lfloor\\dfrac{l+r}{2}\\right\\rfloor=l$，所以中点+1=r，不会超出线段","text":"原题目链接 我们可以取两条线段的中点，若重合就让第二条线段的中点+1 Q:中点+1后不在线段上怎么办？ A:由于C++整数除法自动省略小数，也就是向下取整，若线段长度为1，即l+1=r，那么$\\left\\lfloor\\dfrac{l+r}{2}\\right\\rfloor=l$，所以中点+1=r，不会超出线段 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;inline void read(int &amp;x)//快读，写不写无所谓&#123; char ch; int f=1; x=0; do &#123; if(ch=='-') f=-1; ch=getchar(); &#125;while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')); do &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125;while('0'&lt;=ch&amp;&amp;ch&lt;='9'); x*=f;&#125;int main()&#123; int q; read(q);//读入q while(q--)//循环q次，可换成for(int i=1;i&lt;=q;i++) &#123; int l1,r1,l2,r2; read(l1); read(r1); read(l2); read(r2);//读入l1,r1,l2,r2 int a=(l1+r1)/2; int b=(l2+r2)/2;//取两条线段的中点 printf(\"%d %d\\n\",a,(a==b?b+1:b));//若相等，输出b+1，反之输出b &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"codeforces","slug":"题解/codeforces","permalink":"http://wxwoo.github.io/categories/题解/codeforces/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://wxwoo.github.io/tags/模拟/"}]},{"title":"P3965 [TJOI2013]循环格 题解","slug":"solution-p3965","date":"2019-03-12T16:00:00.000Z","updated":"2019-04-26T08:08:15.547Z","comments":true,"path":"2019/03/13/solution-p3965/","link":"","permalink":"http://wxwoo.github.io/2019/03/13/solution-p3965/","excerpt":"原题目链接 洛谷随机跳题跳到的 有指向，有修改，求最小：明显的最小费用最大流 我们将每个格子看成一个点，然后拆点，如下建边： 原点向每个点连边，流量为1，费用为0 每个点的拆点向汇点连边，流量为1，费用为0 每个点向四周的点连边，流量为1，默认指向费用为0，其他为1","text":"原题目链接 洛谷随机跳题跳到的 有指向，有修改，求最小：明显的最小费用最大流 我们将每个格子看成一个点，然后拆点，如下建边： 原点向每个点连边，流量为1，费用为0 每个点的拆点向汇点连边，流量为1，费用为0 每个点向四周的点连边，流量为1，默认指向费用为0，其他为1 下面我们思考这样建边的正确性 根据最小费用最大流的性质，一定会优先费用为0的边（也就是默认指向） 由于每条边流量都是1，所以不存在一个点有两个指向这种情况 ps：3，4数据点疑似在Windows下生成，使用getchar()读入箭头会WA 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define inf 1e9const int N=3e5+1;struct edge&#123; int from,to,next,cap,flow,cost;&#125;e[N];bool vis[N];int cnt,n,m,sour,sink,head[N],ans,cost,q[N],p[N],d[N],h,t;const int move[4][2]=&#123;-1,0,1,0,0,-1,0,1&#125;;inline void add(int u,int v,int l,int f)&#123; e[++cnt]=(edge)&#123;u,v,head[u],l,0,f&#125;; head[u]=cnt; e[++cnt]=(edge)&#123;v,u,head[v],0,0,-f&#125;; head[v]=cnt;&#125;inline void augment()&#123; int detla=inf,c=0; for(int i=sink;i!=sour;i=e[p[i]].from) &#123; detla=min(detla,e[p[i]].cap-e[p[i]].flow); c+=e[p[i]].cost; &#125; for(int i=sink;i!=sour;i=e[p[i]].from) &#123; e[p[i]].flow+=detla; e[((p[i]-1)^1)+1].flow-=detla; &#125; ans+=detla; cost+=detla*c;&#125;inline bool find()&#123; memset(d,127,sizeof(d)); memset(vis,0,sizeof(vis)); vis[sour]=true; d[sour]=0; q[h=t=1]=sour; while(h&lt;=t) &#123; int x=q[h++]; vis[x]=false; for(int i=head[x];i;i=e[i].next) &#123; if(e[i].cap&gt;e[i].flow&amp;&amp;d[x]+e[i].cost&lt;d[e[i].to]) &#123; if(!vis[e[i].to]) &#123; vis[e[i].to]=true; q[++t]=e[i].to; &#125; d[e[i].to]=d[x]+e[i].cost; p[e[i].to]=i; &#125; &#125; &#125; return d[sink]&lt;inf;&#125;inline void sap()&#123; while(find()) augment();&#125;inline void read(int &amp;x)&#123; char ch; int f=1; x=0; do &#123; if(ch=='-') f=-1; ch=getchar(); &#125;while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')); do &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125;while('0'&lt;=ch&amp;&amp;ch&lt;='9'); x*=f;&#125;inline int get(int x,int y)&#123; return (x-1)*m+y;&#125;int main()&#123; read(n); read(m); sour=0; sink=2*n*m+1; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; char c; cin&gt;&gt;c; int dir; add(sour,get(i,j),1,0); add(get(i,j)+n*m,sink,1,0); if(c=='U') dir=0; else if(c=='D') dir=1; else if(c=='L') dir=2; else if(c=='R') dir=3; for(int k=0;k&lt;4;k++) &#123; int x=i+move[k] [0],y=j+move[k][1]; if(x==n+1) x=1; else if(x==0) x=n; if(y==m+1) y=1; else if(y==0) y=m; if(dir==k) add(get(i,j),get(x,y)+n*m,1,0); else add(get(i,j),get(x,y)+n*m,1,1); &#125; &#125; &#125; sap(); printf(\"%d\",cost); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"http://wxwoo.github.io/categories/题解/洛谷/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://wxwoo.github.io/tags/网络流/"}]},{"title":"CF743A Vladik and flights 题解","slug":"solution-cf743a","date":"2019-03-12T16:00:00.000Z","updated":"2019-04-26T08:05:39.732Z","comments":true,"path":"2019/03/13/solution-cf743a/","link":"","permalink":"http://wxwoo.github.io/2019/03/13/solution-cf743a/","excerpt":"原题目链接 写这题翻译的时候，突然就有了思路 实际上这题重在思考 若a机场和b机场是同一家公司，输出0，这个很容易想到 若a机场和b机场不是同一家公司，输出1，这是为什么呢？","text":"原题目链接 写这题翻译的时候，突然就有了思路 实际上这题重在思考 若a机场和b机场是同一家公司，输出0，这个很容易想到 若a机场和b机场不是同一家公司，输出1，这是为什么呢？ 首先，一定有两个不同公司的机场相邻 我们设这两个机场为$i$和$j$，且$i$与$a$同公司，$j$与$b$同公司 那么就有如下航线： a\\to i\\to j\\to b由于i与j相邻且不为同一家公司，所以总费用为1 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt; inline void read(T &amp;x)//快读&#123; char ch; T f=1; x=0; do &#123; if(ch=='-') f=-1; ch=getchar(); &#125;while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')); do &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=getchar(); &#125;while('0'&lt;=ch&amp;&amp;ch&lt;='9'); x*=f;&#125;int n,a,b;int f[100010];int main()&#123; read(n); read(a); read(b);//输入n,a,b for(int i=1;i&lt;=n;i++) &#123; char c=getchar(); f[i]=c-48;//输入公司 &#125; if(f[a]==f[b])//如果公司相同 putchar('0');//输出0 else//如果公司不同 putchar('1');//输出1 return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://wxwoo.github.io/categories/题解/"},{"name":"codeforces","slug":"题解/codeforces","permalink":"http://wxwoo.github.io/categories/题解/codeforces/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://wxwoo.github.io/tags/模拟/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-03-12T15:30:33.758Z","updated":"2019-03-13T09:59:18.010Z","comments":true,"path":"2019/03/12/hello-world/","link":"","permalink":"http://wxwoo.github.io/2019/03/12/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}